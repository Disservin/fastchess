use crate::game::book::OpeningBook;

/// A pairing generated by the scheduler, representing a single game to be played.
#[derive(Debug, Clone)]
pub struct Pairing {
    pub round_id: usize,
    pub pairing_id: usize,
    pub game_id: usize,
    pub opening_id: Option<usize>,
    pub player1: usize,
    pub player2: usize,
}

/// Determines the scheduling variant and its specific behavior.
#[derive(Debug, Clone, Copy)]
pub enum SchedulerVariant {
    /// Round-robin: every player plays against every other player.
    /// `player1_limit` = `n_players - 1`
    RoundRobin,
    /// Gauntlet: first `n_seeds` players play against all others.
    /// `player1_limit` = `n_seeds`
    Gauntlet { n_seeds: usize },
}

/// Tournament scheduler that generates pairings for games.
///
/// Replaces the C++ `Scheduler` → `TournamentSchedulerBase` → `RoundRobinScheduler` / `GauntletScheduler`
/// virtual class hierarchy with a single struct + enum variant.
///
/// The scheduler **owns** the opening book to avoid lifetime issues with
/// `Arc<Mutex<Scheduler>>`. Since opening books can be very large (up to 1GB),
/// ownership ensures there's only one copy in memory.
pub struct Scheduler {
    opening_book: OpeningBook,
    variant: SchedulerVariant,
    opening: Option<usize>,
    n_players: usize,
    n_rounds: usize,
    n_games_per_round: usize,
    current_round: usize,
    game_counter: usize,
    player1: usize,
    player2: usize,
    games_per_pair: usize,
    pair_counter: usize,
}

impl Scheduler {
    /// Create a new scheduler.
    ///
    /// # Arguments
    /// * `opening_book` - The opening book (ownership is transferred to the scheduler)
    /// * `variant` - The scheduling variant (RoundRobin or Gauntlet)
    /// * `players` - Number of players/engines
    /// * `rounds` - Number of rounds
    /// * `games` - Number of games per round (per pair)
    /// * `played_games` - Number of games already played (for resumption)
    ///
    /// # Panics
    /// Panics if `players < 2`, `rounds < 1`, or `games < 1`.
    pub fn new(
        opening_book: OpeningBook,
        variant: SchedulerVariant,
        players: usize,
        rounds: usize,
        games: usize,
        played_games: usize,
    ) -> Self {
        assert!(
            players >= 2 && rounds >= 1 && games >= 1,
            "Invalid number of players, rounds, or games per round"
        );

        // For Gauntlet, clamp n_seeds to at most players - 1
        let variant = match variant {
            SchedulerVariant::Gauntlet { n_seeds } => SchedulerVariant::Gauntlet {
                n_seeds: n_seeds.min(players - 1),
            },
            other => other,
        };

        let pair_counter = played_games / games;
        let current_round = pair_counter + 1;

        Self {
            opening_book,
            variant,
            opening: None,
            n_players: players,
            n_rounds: rounds,
            n_games_per_round: games,
            current_round,
            game_counter: played_games,
            player1: 0,
            player2: 1,
            games_per_pair: 0,
            pair_counter,
        }
    }

    /// Returns the total number of games in this tournament.
    pub fn total(&self) -> usize {
        let n_pairings = match self.variant {
            SchedulerVariant::RoundRobin => self.n_players * (self.n_players - 1) / 2,
            SchedulerVariant::Gauntlet { n_seeds } => {
                n_seeds * self.n_players - n_seeds * (n_seeds + 1) / 2
            }
        };
        n_pairings * self.n_rounds * self.n_games_per_round
    }

    /// Returns the player1 index limit for the current variant.
    fn player1_limit(&self) -> usize {
        match self.variant {
            SchedulerVariant::RoundRobin => self.n_players - 1,
            SchedulerVariant::Gauntlet { n_seeds } => n_seeds,
        }
    }

    /// Look up an opening from the book by index.
    ///
    /// This is used by the tournament runner to resolve `pairing.opening_id`
    /// into an actual `Opening` after the scheduler has been unlocked.
    pub fn get_opening(&self, id: Option<usize>) -> crate::game::book::Opening {
        self.opening_book.get(id)
    }

    /// Generate the next game pairing, or `None` if the tournament is complete.
    pub fn next(&mut self) -> Option<Pairing> {
        // Check if the current round is beyond the number of rounds
        if self.current_round > self.n_rounds {
            return None;
        }

        if self.games_per_pair == 0 {
            self.opening = self.opening_book.fetch_id();
        }

        self.game_counter += 1;

        let pairing = Pairing {
            round_id: self.current_round,
            game_id: self.game_counter,
            player1: self.player1,
            player2: self.player2,
            pairing_id: self.pair_counter,
            opening_id: self.opening,
        };

        // Increment the games between the current player pair
        self.games_per_pair += 1;

        // If we've exhausted the games between the current player pair, move to the next pair
        if self.games_per_pair >= self.n_games_per_round {
            self.games_per_pair = 0;
            self.player2 += 1;
            self.pair_counter += 1;

            if self.player2 >= self.n_players {
                self.player1 += 1;
                self.player2 = self.player1 + 1;
            }

            // If we've exhausted all pairs for this round, move to the next round
            if self.player1 >= self.player1_limit() {
                self.current_round += 1;
                self.player1 = 0;
                self.player2 = 1;
            }
        }

        Some(pairing)
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::game::book::OpeningBook;

    fn make_empty_book() -> OpeningBook {
        OpeningBook::new(
            "",
            crate::types::FormatType::Epd,
            crate::types::OrderType::Sequential,
            0,
            0,
            1,
            1,
            0,
            crate::types::VariantType::Standard,
        )
        .unwrap()
    }

    #[test]
    fn test_round_robin_total_3_players() {
        let book = make_empty_book();
        let sched = Scheduler::new(
            book,
            SchedulerVariant::RoundRobin,
            3, // players
            1, // rounds
            2, // games per round
            0, // played
        );
        // 3 players => 3 pairings (0v1, 0v2, 1v2), 1 round, 2 games each = 6
        assert_eq!(sched.total(), 6);
    }

    #[test]
    fn test_round_robin_total_4_players_2_rounds() {
        let book = make_empty_book();
        let sched = Scheduler::new(
            book,
            SchedulerVariant::RoundRobin,
            4, // players
            2, // rounds
            1, // games per round
            0,
        );
        // 4 players => 6 pairings, 2 rounds, 1 game each = 12
        assert_eq!(sched.total(), 12);
    }

    #[test]
    fn test_round_robin_generates_all_pairings() {
        let book = make_empty_book();
        let mut sched = Scheduler::new(book, SchedulerVariant::RoundRobin, 3, 1, 1, 0);
        // Should produce exactly 3 pairings: (0,1), (0,2), (1,2)
        let total = sched.total();
        assert_eq!(total, 3);

        let p1 = sched.next().unwrap();
        assert_eq!((p1.player1, p1.player2), (0, 1));
        assert_eq!(p1.game_id, 1);
        assert_eq!(p1.round_id, 1);

        let p2 = sched.next().unwrap();
        assert_eq!((p2.player1, p2.player2), (0, 2));
        assert_eq!(p2.game_id, 2);

        let p3 = sched.next().unwrap();
        assert_eq!((p3.player1, p3.player2), (1, 2));
        assert_eq!(p3.game_id, 3);

        // No more pairings
        assert!(sched.next().is_none());
    }

    #[test]
    fn test_round_robin_multi_games_per_pair() {
        let book = make_empty_book();
        let mut sched = Scheduler::new(
            book,
            SchedulerVariant::RoundRobin,
            2, // 2 players
            1, // 1 round
            3, // 3 games per pair
            0,
        );
        assert_eq!(sched.total(), 3);

        for i in 0..3 {
            let p = sched.next().unwrap();
            assert_eq!((p.player1, p.player2), (0, 1));
            assert_eq!(p.game_id, i + 1);
            assert_eq!(p.pairing_id, 0); // same pair for all 3 games
        }
        assert!(sched.next().is_none());
    }

    #[test]
    fn test_gauntlet_total() {
        let book = make_empty_book();
        let sched = Scheduler::new(
            book,
            SchedulerVariant::Gauntlet { n_seeds: 1 },
            4, // players
            1, // rounds
            2, // games per round
            0,
        );
        // 1 seed vs 3 opponents = 3 pairings, 1 round, 2 games = 6
        assert_eq!(sched.total(), 6);
    }

    #[test]
    fn test_gauntlet_generates_pairings() {
        let book = make_empty_book();
        let mut sched = Scheduler::new(
            book,
            SchedulerVariant::Gauntlet { n_seeds: 1 },
            3, // players
            1, // round
            1, // game per pair
            0,
        );
        // Seed 0 plays against 1 and 2
        assert_eq!(sched.total(), 2);

        let p1 = sched.next().unwrap();
        assert_eq!((p1.player1, p1.player2), (0, 1));

        let p2 = sched.next().unwrap();
        assert_eq!((p2.player1, p2.player2), (0, 2));

        assert!(sched.next().is_none());
    }

    #[test]
    fn test_gauntlet_2_seeds() {
        let book = make_empty_book();
        let mut sched = Scheduler::new(
            book,
            SchedulerVariant::Gauntlet { n_seeds: 2 },
            4, // players
            1,
            1,
            0,
        );
        // Seed 0 vs {1,2,3} = 3, Seed 1 vs {2,3} = 2 => total = 5
        assert_eq!(sched.total(), 5);

        let mut pairs = vec![];
        while let Some(p) = sched.next() {
            pairs.push((p.player1, p.player2));
        }
        assert_eq!(pairs, vec![(0, 1), (0, 2), (0, 3), (1, 2), (1, 3)]);
    }

    #[test]
    fn test_gauntlet_seeds_clamped() {
        let book = make_empty_book();
        // n_seeds=10 but only 3 players, should clamp to 2
        let sched = Scheduler::new(book, SchedulerVariant::Gauntlet { n_seeds: 10 }, 3, 1, 1, 0);
        // Clamped to 2 seeds => same as round robin with 3 players = 3 pairings
        assert_eq!(sched.total(), 3);
    }

    #[test]
    fn test_resumption() {
        let book = make_empty_book();
        // 2 players, 1 round, 4 games per pair. Resume after 2 played.
        let mut sched = Scheduler::new(
            book,
            SchedulerVariant::RoundRobin,
            2,
            1,
            4,
            2, // 2 already played
        );
        assert_eq!(sched.total(), 4);

        // game_counter starts at 2, so next game_id = 3
        let p1 = sched.next().unwrap();
        assert_eq!(p1.game_id, 3);

        let p2 = sched.next().unwrap();
        assert_eq!(p2.game_id, 4);

        // But note: the C++ code doesn't truly fast-forward the pairing state on resumption.
        // It only advances game_counter and current_round. The pair iteration still starts from (0,1).
        // This test verifies the game_id numbering continues correctly.
    }

    #[test]
    fn test_multi_round() {
        let book = make_empty_book();
        let mut sched = Scheduler::new(
            book,
            SchedulerVariant::RoundRobin,
            2, // 2 players
            3, // 3 rounds
            1, // 1 game per pair
            0,
        );
        assert_eq!(sched.total(), 3); // 1 pair * 3 rounds * 1 game = 3

        for round in 1..=3 {
            let p = sched.next().unwrap();
            assert_eq!(p.round_id, round);
            assert_eq!((p.player1, p.player2), (0, 1));
        }
        assert!(sched.next().is_none());
    }

    // 2 players, 2 games per pair, 2 rounds = 4 total games
    #[test]
    fn test_multi_games_multi_rounds() {
        let book = make_empty_book();
        let mut sched = Scheduler::new(
            book,
            SchedulerVariant::RoundRobin,
            2, // 2 players => 1 pair
            2, // 2 rounds
            2, // 2 games per pair
            0,
        );
        assert_eq!(sched.total(), 4); // 1 pair * 2 rounds * 2 games = 4

        for round in 1..=2 {
            for _ in 1..=2 {
                let p = sched.next().unwrap();
                assert_eq!(p.round_id, round);
                assert_eq!((p.player1, p.player2), (0, 1));
            }
        }
        assert!(sched.next().is_none());
    }
}
